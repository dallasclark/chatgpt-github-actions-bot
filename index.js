const core = require("@actions/core");
const fs = require("fs");
require('dotenv').config();
const openai = require("openai");

const descriptions = core.getInput("descriptions") || process.env.descriptions;

const OPENAI_API_MODEL = core.getInput("OPENAI_API_MODEL") || process.env.OPENAI_API_MODEL;

const OPENAI_API_ORGANIZATION_ID = core.getInput("OPENAI_API_ORGANIZATION_ID") || process.env.OPENAI_API_ORGANIZATION_ID;

const OPENAI_API_PROJECT_ID = core.getInput("OPENAI_API_PROJECT_ID") || process.env.OPENAI_API_PROJECT_ID;

const OPENAI_API_TEMPERATURE = 0.7;

const OPENAI_API_TOKEN = core.getInput("OPENAI_API_TOKEN") || process.env.OPENAI_API_TOKEN;

function log(message) {
  // Github Actions has a limit of 1,000 characters per message. We will output multiple messages if needed (using 900 just to be safe).
  if (message.length > 900) {
    // Truncate the message to 900 characters
    let currentMessagePosition = 0;
    let truncatedMessage = '';
    while (currentMessagePosition < message.length) {
      truncatedMessage = message.substring(currentMessagePosition, currentMessagePosition + 900);
      core.info(truncatedMessage);
      currentMessagePosition += 900;
    }
  } else {
    core.info(message);
  }
}

function validateInputs() {
  let isError = false;
  const errors = [];

  if (!OPENAI_API_ORGANIZATION_ID) {
    errors.push('Missing OPENAI_API_ORGANIZATION_ID input');
    isError = true;
  }

  if (!OPENAI_API_PROJECT_ID) {
    errors.push('Missing OPENAI_API_PROJECT_ID input');
    isError = true;
  }

  if (!OPENAI_API_TOKEN) {
    errors.push('Missing OPENAI_API_TOKEN input');
    isError = true;
  }

  if (isError) {
    core.error("Input validation errors");
    core.setFailed(errors.join("\n"));
    process.exit();
  }
}

function debugMessages() {
  core.startGroup("Debug messages");
  core.info(`OPENAI_API_MODEL: ${OPENAI_API_MODEL}`);
  core.info(`Descriptions: ${descriptions}`);
  core.endGroup();
}

async function generateFiles() {
  try {
    const _openai = new openai({
      apiKey: OPENAI_API_TOKEN,
      organization: OPENAI_API_ORGANIZATION_ID,
      project: OPENAI_API_PROJECT_ID,
      temperature: OPENAI_API_TEMPERATURE,
    });

    const openaiChatCompletionContent = `You are a very helpful developer. Your job is to write code. Your goal is to make code that is production ready.
      
      Your Task:
      1. Stick to the descriptions provided below, don't add anything else.
      2. Use the minimum amount of required files.
      3. Make the minimum amount of assumptions about the rest of the repository.
      4. Provide a response as an array, with each array element being a JSON object.
      5. Each JSON object should contain a 'filename' key, and the contents of the file should be in a 'content' key.
      
      Example of the Full Expected Output for 2 files generated:
      [
        {
          "filename": "the/path/to/file.txt",
          "content": "The code contents of the file"
        },
        {
          "filename": "the/path/to/file.txt",
          "content": "The code contents of the file"
        }
      ]

      Your 'descriptions' are: ${descriptions}`;
    log(`OpenAI Prompt: ${openaiChatCompletionContent}`);
  
    const completion = await _openai.chat.completions.create({
      messages: [
        {
          role: "system",
          content: openaiChatCompletionContent,
        },
      ],
      model: OPENAI_API_MODEL
    });

    if (completion.error) {
      core.error(completion.error);
      core.setFailed(completion.error.message);
      process.exit();
    }

    else {
      core.startGroup("OpenAI choices response");
      log(JSON.stringify(completion.choices));
      core.endGroup();
    }
    
    // Parse the response
    // TODO: Validate the response is valid JSON and the response structure we're expecting
    // Occassionally the response is an object with a 'response' key
    const content = JSON.parse(completion.choices[0].message.content);
    let files = typeof content.response !== "undefined" ? content.response : content;

    if (!Array.isArray(files)) {
      files = [files];
    }

    core.startGroup("Files generated by OpenAI");
    console.log(files);
    log(JSON.stringify(files));
    core.endGroup();
    return files;
  } catch (error) {
    core.setFailed(error.message);
  }
}

function writeFilesToRepository(files) {
  for (const file of files) {
    try {
      // File path
      let filePath = file.filename.lastIndexOf("/") > 0 ? file.filename.substring(0, file.filename.lastIndexOf("/") + 1) : "";
      filePath = filePath.indexOf("/") === 0 ? filePath.substring(1) : filePath;
      if (filePath.length > 0 && !fs.existsSync(filePath)) {
        fs.mkdirSync(filePath, { recursive: true });
      }

      // File name
      const fileName = file.filename.substring(file.filename.lastIndexOf("/") + 1);

      // File content
      const filePathAndName = `${filePath}${fileName}`;
      file.filename = filePathAndName;
      fs.writeFileSync(filePathAndName, file.content);

      // Debug
      core.startGroup(`File written to repository: ${filePathAndName}`);
      log(file.content);
      core.endGroup();
    } catch (error) {
      console.error(error);
      core.setFailed(error.message);
      process.exit();
    }
  }

  core.setOutput("files", files.map(file => file.filename).join("\n"));
}

async function run() {
  validateInputs();
  debugMessages();

  const files = await generateFiles();
  // TODO: Validate the response is valid JSON and the response structure we're expecting
  writeFilesToRepository(files);
}

run();
